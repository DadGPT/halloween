<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Halloween Contest - Admin</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        /* Mobile Frame for Desktop */
        @media (min-width: 768px) {
            body {
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                padding: 20px;
            }

            .mobile-frame {
                width: 390px;
                height: 844px;
                background: #000;
                border-radius: 40px;
                box-shadow: 0 0 0 12px #222, 0 0 0 14px #000, 0 20px 60px rgba(0,0,0,0.5);
                overflow: hidden;
                position: relative;
            }

            .mobile-frame::before {
                content: '';
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 150px;
                height: 30px;
                background: #000;
                border-radius: 0 0 20px 20px;
                z-index: 10;
            }

            .app-container {
                height: 100%;
                position: relative;
                overflow: hidden;
            }
        }

        @media (max-width: 767px) {
            .mobile-frame {
                width: 100vw;
                height: 100vh;
            }

            .app-container {
                width: 100vw;
                height: 100vh;
                position: relative;
                overflow: hidden;
            }
        }

        /* App Styles */
        .app-container {
            background: linear-gradient(180deg, #1a0033 0%, #330066 50%, #4d0099 100%);
            position: relative;
        }

        .app-content {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            -webkit-overflow-scrolling: touch;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: rgba(26, 0, 51, 0.95);
            backdrop-filter: blur(10px);
            z-index: 100;
            padding: 15px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.3);
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header h1 {
            font-size: 1.3em;
            color: #ff6b00;
            font-weight: 700;
        }

        .menu-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 107, 0, 0.2);
            border: 2px solid #ff6b00;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .menu-btn:active {
            transform: scale(0.95);
            background: rgba(255, 107, 0, 0.4);
        }

        .menu-btn span {
            width: 20px;
            height: 2px;
            background: #ff6b00;
            border-radius: 2px;
            transition: all 0.3s;
        }

        /* Side Menu */
        .side-menu {
            position: absolute;
            top: 0;
            right: -100%;
            width: 75%;
            max-width: 300px;
            height: 100%;
            background: rgba(26, 0, 51, 0.98);
            backdrop-filter: blur(20px);
            z-index: 200;
            transition: right 0.3s ease;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }

        .side-menu.active {
            right: 0;
        }

        .menu-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 107, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .menu-title {
            color: #ff6b00;
            font-size: 1.2em;
            font-weight: 600;
        }

        .close-menu {
            width: 30px;
            height: 30px;
            background: transparent;
            border: 2px solid #ff6b00;
            border-radius: 50%;
            color: #ff6b00;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .menu-items {
            padding: 20px;
        }

        .menu-item {
            display: block;
            padding: 15px;
            margin-bottom: 10px;
            background: rgba(255, 107, 0, 0.1);
            border: 1px solid rgba(255, 107, 0, 0.3);
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            font-size: 1.1em;
            transition: all 0.3s;
        }

        .menu-item:active {
            background: rgba(255, 107, 0, 0.3);
            transform: scale(0.98);
        }

        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 199;
            display: none;
        }

        .menu-overlay.active {
            display: block;
        }

        /* Main Content */
        .main-content {
            padding: 20px 15px 30px;
        }

        /* Add Entry Form */
        .form-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 107, 0, 0.3);
        }

        .form-card h2 {
            color: #ff6b00;
            font-size: 1.4em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: #ff8c00;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid rgba(255, 107, 0, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1em;
            transition: all 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #ff6b00;
            background: rgba(255, 255, 255, 0.1);
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        /* Avatar Tabs */
        /* Image Upload */
        .upload-area {
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            text-align: center;
        }

        .upload-label {
            display: block;
            padding: 30px;
            border: 3px dashed rgba(255, 107, 0, 0.5);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-label:hover {
            border-color: #ff6b00;
            background: rgba(255, 107, 0, 0.1);
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .upload-text {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
        }

        .upload-input {
            display: none;
        }

        .image-preview {
            margin-top: 15px;
            display: none;
        }

        .image-preview img {
            width: 150px;
            height: 150px;
            object-fit: cover;
            border-radius: 12px;
            border: 3px solid #ff6b00;
        }

        .image-preview-container {
            position: relative;
            display: inline-block;
        }

        .remove-image {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 30px;
            height: 30px;
            background: rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2em;
        }

        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: #000;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 107, 0, 0.2);
            color: #ff6b00;
            border: 2px solid #ff6b00;
        }

        .btn-danger {
            background: rgba(255, 0, 0, 0.2);
            color: #ff4444;
            border: 2px solid #ff4444;
        }

        .btn-full {
            grid-column: 1 / -1;
        }

        /* Entries List */
        .entries-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 107, 0, 0.3);
        }

        .entries-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .entries-header h2 {
            color: #ff6b00;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stats-badge {
            background: rgba(255, 107, 0, 0.2);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #ff8c00;
            border: 1px solid #ff6b00;
        }

        /* Entry Cards */
        .entries-grid {
            display: grid;
            gap: 15px;
        }

        .entry-card {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 15px;
            border: 2px solid rgba(255, 107, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            transition: all 0.3s;
        }

        .entry-card:active {
            transform: scale(0.98);
            background: rgba(255, 107, 0, 0.1);
        }

        .entry-avatar {
            font-size: 3em;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .entry-avatar img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 12px;
            border: 2px solid #ff6b00;
        }

        .entry-info {
            flex: 1;
        }

        .entry-name {
            color: #ff8c00;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .entry-type {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85em;
            margin-bottom: 8px;
        }

        .entry-votes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .vote-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .vote-badge {
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .remove-vote-btn {
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff4444;
            border-radius: 50%;
            color: #ff4444;
            font-size: 0.8em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
        }

        .remove-vote-btn:hover {
            background: rgba(255, 0, 0, 0.4);
        }

        .remove-vote-btn:active {
            transform: scale(0.9);
        }

        .delete-entry {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff4444;
            border-radius: 50%;
            color: #ff4444;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2em;
        }

        .delete-entry:active {
            transform: scale(0.9);
            background: rgba(255, 0, 0, 0.4);
        }

        .edit-entry {
            position: absolute;
            top: 10px;
            right: 50px;
            width: 30px;
            height: 30px;
            background: rgba(255, 107, 0, 0.2);
            border: 2px solid #ff6b00;
            border-radius: 50%;
            color: #ff6b00;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.1em;
        }

        .edit-entry:active {
            transform: scale(0.9);
            background: rgba(255, 107, 0, 0.4);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.5);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Results Modal */
        .modal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 500;
            padding: 20px;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 50px;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a0033, #330066);
            border-radius: 20px;
            padding: 25px;
            width: 100%;
            max-width: 500px;
            border: 2px solid #ff6b00;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .modal-header h2 {
            color: #ff6b00;
            font-size: 1.5em;
        }

        .close-modal {
            width: 35px;
            height: 35px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff4444;
            border-radius: 50%;
            color: #ff4444;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5em;
        }

        .results-category {
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 15px;
        }

        .results-category h3 {
            color: #ff8c00;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .winner {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.5);
        }

        .winner .avatar {
            font-size: 2.5em;
        }

        .winner .avatar img {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 10px;
        }

        .winner-info {
            flex: 1;
        }

        .winner-name {
            color: #ffd700;
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .winner-votes {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
        }

        .no-winner {
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
        }

        /* Enhanced Results Styles */
        .stats-summary {
            background: rgba(255, 107, 0, 0.1);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 107, 0, 0.3);
        }

        .stats-summary h3 {
            color: #ff6b00;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .summary-stats {
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }

        .stat-item {
            flex: 1;
            text-align: center;
        }

        .stat-label {
            display: block;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            display: block;
            color: #ff8c00;
            font-size: 1.4em;
            font-weight: 600;
        }

        .category-stats {
            margin-bottom: 15px;
            text-align: center;
        }

        .total-votes {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 12px;
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .other-entries {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
        }

        .other-entries h4 {
            color: #ff8c00;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .entry-result {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .entry-result.first-place {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .rank {
            color: #ff8c00;
            font-weight: 600;
            min-width: 20px;
        }

        .result-avatar {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }

        .result-avatar img {
            width: 30px;
            height: 30px;
            object-fit: cover;
            border-radius: 6px;
        }

        .result-name {
            flex: 1;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        .result-votes {
            color: #ff8c00;
            font-weight: 600;
            font-size: 0.9em;
        }

        /* Toast */
        .toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 15px 25px;
            border-radius: 30px;
            border: 2px solid #ff6b00;
            opacity: 0;
            transition: all 0.3s;
            z-index: 600;
            max-width: 80%;
            text-align: center;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Custom Confirmation Modal */
        .confirm-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 11000;
            padding: 20px;
        }

        .confirm-modal-overlay.active {
            display: flex;
        }

        .confirm-modal {
            background: linear-gradient(135deg, rgba(30, 0, 50, 0.95), rgba(10, 0, 30, 0.95));
            border: 3px solid #ff6b00;
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 100%;
            text-align: center;
            box-shadow: 0 10px 50px rgba(255, 107, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .confirm-modal-icon {
            font-size: 4em;
            margin-bottom: 15px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .confirm-modal-title {
            color: #ff6b00;
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 15px;
        }

        .confirm-modal-message {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1em;
            line-height: 1.5;
            margin-bottom: 25px;
        }

        .confirm-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirm-modal-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 12px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .confirm-modal-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .confirm-modal-cancel:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.05);
        }

        .confirm-modal-confirm {
            background: linear-gradient(135deg, #ff6b00, #ff8c00);
            color: white;
            border: 2px solid #ff6b00;
        }

        .confirm-modal-confirm:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, #ff8c00, #ff6b00);
        }
    </style>
</head>
<body>
    <div class="mobile-frame">
        <div class="app-container">
            <div class="app-content">
                <!-- Header -->
                <div class="header">
                    <div class="header-content">
                        <div class="header-title">
                            <span style="font-size: 1.5em;">‚öôÔ∏è</span>
                            <h1>Admin Panel</h1>
                        </div>
                        <div class="menu-btn" onclick="toggleMenu()">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                </div>

                <!-- Main Content -->
                <div class="main-content">
                    <!-- Add Entry Form -->
                    <div class="form-card">
                        <h2>
                            <span>‚ûï</span>
                            <span>Add New Entry</span>
                        </h2>
                        
                        <div class="form-group">
                            <label>Name / Team Name</label>
                            <input type="text" id="entryName" placeholder="e.g., The Addams Family">
                        </div>

                        <div class="form-group">
                            <label>Entry Type</label>
                            <select id="entryType">
                                <option value="individual">Individual</option>
                                <option value="couple">Couple/Group</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label>Upload Photo</label>
                            <div class="upload-area">
                                <label for="imageUpload" class="upload-label">
                                    <div class="upload-icon">üì∏</div>
                                    <div class="upload-text">Tap to upload photo</div>
                                </label>
                                <input type="file" id="imageUpload" class="upload-input" accept="image/*" onchange="handleImageUpload(event)">
                                <div class="image-preview" id="imagePreview">
                                    <div class="image-preview-container">
                                        <img id="previewImg" src="" alt="Preview">
                                        <div class="remove-image" onclick="removeImage()">√ó</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="action-buttons">
                            <button class="btn btn-primary btn-full" onclick="addEntry()">Add Entry</button>
                        </div>
                    </div>

                    <!-- Contest Timing Controls -->
                    <div class="form-card">
                        <h2 style="cursor: pointer; display: flex; align-items: center; justify-content: space-between;" onclick="toggleTimingCard()">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span>‚è∞</span>
                                <span>Contest Timing</span>
                            </div>
                            <span id="timingCardToggle" style="font-size: 0.8em; color: rgba(255, 255, 255, 0.6);">‚ñº</span>
                        </h2>

                        <div id="timingCardContent">
                            <div class="form-group">
                                <label for="timingMode">Timing Mode</label>
                                <select id="timingMode" onchange="toggleTimingSettings()">
                                    <option value="disabled">Disabled (Always Allow Voting)</option>
                                    <option value="enabled">Enabled (Time-Based Phases)</option>
                                </select>
                                <div style="margin-top: 8px; padding: 12px; background: rgba(0, 150, 255, 0.1); border: 1px solid rgba(0, 150, 255, 0.3); border-radius: 8px; color: rgba(255, 255, 255, 0.9); font-size: 0.85em;">
                                    <strong>‚ÑπÔ∏è Timezone:</strong> All times are in <strong>Eastern Time (ET)</strong>. The system automatically handles timezone conversion for both admins and voters, regardless of their local timezone.
                                </div>
                            </div>

                        <div id="timingSettings" style="display: none;">
                            <div class="form-group">
                                <label>Voting Period</label>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                    <div>
                                        <label style="font-size: 0.9em; margin-bottom: 5px;">Start Time (ET)</label>
                                        <input type="datetime-local" id="votingStart" value="2025-10-25T19:00">
                                    </div>
                                    <div>
                                        <label style="font-size: 0.9em; margin-bottom: 5px;">End Time (ET)</label>
                                        <input type="datetime-local" id="votingEnd" value="2025-10-25T21:00">
                                    </div>
                                </div>
                                <div style="color: rgba(255, 255, 255, 0.6); font-size: 0.85em; margin-top: 5px;">
                                    <strong>Before:</strong> Pre-show period (uploads allowed, voting disabled)<br>
                                    <strong>During:</strong> Active voting period (uploads and voting allowed)<br>
                                    <strong>After:</strong> Contest closed (no uploads or voting)
                                </div>
                            </div>

                            <div class="action-buttons">
                                <button class="btn btn-primary btn-full" onclick="saveTimingSettings()">Save Timing Settings</button>
                            </div>
                        </div>

                        <div class="timing-status" id="timingStatus">
                            <div style="background: rgba(255, 107, 0, 0.1); padding: 15px; border-radius: 12px; border: 1px solid rgba(255, 107, 0, 0.3);">
                                <div style="color: #ff6b00; font-weight: 600; margin-bottom: 5px; display: flex; align-items: center; gap: 8px;">
                                    <span id="phaseIcon">üîß</span>
                                    <span>Current Status:</span>
                                </div>
                                <div style="color: rgba(255, 255, 255, 0.8); font-size: 1.1em;" id="currentPhase">Timing controls disabled - voting always available</div>
                                <div style="color: rgba(255, 255, 255, 0.6); font-size: 0.9em; margin-top: 5px;" id="nextPhase"></div>
                            </div>
                        </div>

                        <div id="manualOverrides" style="display: none; margin-top: 15px;">
                            <div style="background: rgba(255, 0, 0, 0.1); padding: 15px; border-radius: 12px; border: 1px solid rgba(255, 0, 0, 0.3);">
                                <div style="color: #ff4444; font-weight: 600; margin-bottom: 10px;">‚ö†Ô∏è Manual Phase Override</div>
                                <div class="action-buttons">
                                    <button class="btn btn-secondary" onclick="setPhase('preshow')">Force Pre-Show</button>
                                    <button class="btn btn-primary" onclick="setPhase('voting')">Force Voting</button>
                                    <button class="btn btn-danger" onclick="setPhase('closed')">Force Closed</button>
                                    <button class="btn btn-secondary btn-full" onclick="setPhase('auto')">Return to Auto</button>
                                </div>
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- Entries List -->
                    <div class="entries-section">
                        <div class="entries-header">
                            <h2>
                                <span>üìã</span>
                                <span>Current Entries</span>
                            </h2>
                            <div class="stats-badge" id="entriesCount">0 entries</div>
                        </div>
                        
                        <div class="entries-grid" id="entriesList">
                            <!-- Entries will be dynamically added here -->
                        </div>
                    </div>
                </div>

                <!-- Side Menu -->
                <div class="side-menu" id="sideMenu">
                    <div class="menu-header">
                        <div class="menu-title">Menu</div>
                        <div class="close-menu" onclick="toggleMenu()">√ó</div>
                    </div>
                    <div class="menu-items">
                        <a href="/vote" class="menu-item">üó≥Ô∏è Voting Interface</a>
                        <a href="#" class="menu-item" onclick="showResults(); return false;">üìä View Results</a>
                        <a href="#" class="menu-item" onclick="resetAllVotes(); return false;">üîÑ Reset All Votes</a>
                        <a href="#" class="menu-item" onclick="clearAllData(); return false;">üóëÔ∏è Clear All Data</a>
                        <a href="#" class="menu-item" onclick="exportData(); return false;">üíæ Export Data</a>
                    </div>
                </div>
                <div class="menu-overlay" id="menuOverlay" onclick="toggleMenu()"></div>

                <!-- Results Modal -->
                <div class="modal" id="resultsModal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>üèÜ Contest Results</h2>
                            <div class="close-modal" onclick="closeModal()">√ó</div>
                        </div>
                        <div id="resultsContent">
                            <!-- Results will be dynamically added here -->
                        </div>
                    </div>
                </div>

                <!-- Edit Entry Modal -->
                <div class="modal" id="editModal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>‚úé Edit Entry</h2>
                            <div class="close-modal" onclick="closeEditModal()">√ó</div>
                        </div>
                        <div id="editFormContainer">
                            <div class="form-group">
                                <label>Name / Team Name</label>
                                <input type="text" id="editEntryName" placeholder="e.g., The Addams Family">
                            </div>

                            <div class="form-group">
                                <label>Entry Type</label>
                                <select id="editEntryType">
                                    <option value="individual">Individual</option>
                                    <option value="couple">Couple/Group</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label>Photo (cannot be changed)</label>
                                <div class="image-preview" id="editImagePreview">
                                    <div class="image-preview-container">
                                        <img id="editPreviewImg" src="" alt="Preview">
                                    </div>
                                </div>
                            </div>

                            <div class="action-buttons">
                                <button class="btn btn-secondary" onclick="closeEditModal()">Cancel</button>
                                <button class="btn btn-primary" onclick="saveEditEntry()">Save Changes</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Toast -->
                <div class="toast" id="toast"></div>

                <!-- Custom Confirmation Modal -->
                <div class="confirm-modal-overlay" id="confirmModalOverlay">
                    <div class="confirm-modal">
                        <div class="confirm-modal-icon">‚ö†Ô∏è</div>
                        <div class="confirm-modal-title" id="confirmModalTitle">Confirm Action</div>
                        <div class="confirm-modal-message" id="confirmModalMessage">Are you sure?</div>
                        <div class="confirm-modal-buttons">
                            <button class="confirm-modal-btn confirm-modal-cancel" id="confirmModalCancel">Cancel</button>
                            <button class="confirm-modal-btn confirm-modal-confirm" id="confirmModalConfirm">Confirm</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data
        let entries = [];
        let selectedImage = null;
        let uploadedFile = null; // Store the actual File object for server upload

        // Edit state
        let editingEntry = null;
        
        // Secret key sequence
        let keySequence = '';
        let secretTrigger = 'ttttt';

        // Categories
        const categories = [
            { id: 'couple', name: 'Best Couple', emoji: 'üíë' },
            { id: 'funny', name: 'Funniest', emoji: 'üòÇ' },
            { id: 'scary', name: 'Scariest', emoji: 'üëª' },
            { id: 'overall', name: 'Best Overall', emoji: 'üèÜ' }
        ];

        // Initialize
        async function init() {
            await loadEntries();
            renderEntries();
            updateStats();
        }

        // Load entries from API
        async function loadEntries() {
            try {
                const response = await fetch('/api/entries');
                if (response.ok) {
                    entries = await response.json();
                } else {
                    console.error('Failed to load entries from API');
                    // Fallback to localStorage
                    const saved = localStorage.getItem('halloweenEntries');
                    if (saved) {
                        entries = JSON.parse(saved);
                    }
                }
            } catch (error) {
                console.error('Error loading entries:', error);
                // Fallback to localStorage
                const saved = localStorage.getItem('halloweenEntries');
                if (saved) {
                    entries = JSON.parse(saved);
                }
            }
        }

        // Save entries
        function saveEntries() {
            localStorage.setItem('halloweenEntries', JSON.stringify(entries));
        }

        // Switch avatar tab

        // Handle image upload
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                uploadedFile = file; // Store the actual File object for upload
                const reader = new FileReader();
                reader.onload = function(e) {
                    selectedImage = e.target.result;
                    document.getElementById('previewImg').src = selectedImage;
                    document.getElementById('imagePreview').style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        }

        // Remove image
        function removeImage() {
            selectedImage = null;
            uploadedFile = null;
            document.getElementById('imageUpload').value = '';
            document.getElementById('imagePreview').style.display = 'none';
        }

        // Add entry
        async function addEntry() {
            const name = document.getElementById('entryName').value.trim();
            const type = document.getElementById('entryType').value;

            if (!name) {
                showToast('Please enter a name!');
                return;
            }

            if (!uploadedFile) {
                showToast('Please upload a photo!');
                return;
            }

            try {
                const formData = new FormData();
                formData.append('photo', uploadedFile);
                formData.append('name', name);
                formData.append('type', type);
                formData.append('description', '');

                console.log('Uploading entry to server...');
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Upload failed');
                }

                const result = await response.json();
                console.log('Upload successful:', result);

                // Reload entries from server
                await loadEntries();
                renderEntries();
                updateStats();

                // Reset form
                document.getElementById('entryName').value = '';
                document.getElementById('entryType').value = 'individual';
                removeImage();

                showToast('Entry added successfully! üéâ');
            } catch (error) {
                console.error('Upload error:', error);
                showToast('Failed to upload: ' + error.message);
            }
        }

        // Delete entry
        async function deleteEntry(id) {
            const confirmed = await showConfirm(
                'Delete this entry?',
                'Delete Entry'
            );
            if (!confirmed) {
                return;
            }

            try {
                console.log('Deleting entry:', id);
                const response = await fetch(`/api/entries/${id}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Delete failed');
                }

                const result = await response.json();
                console.log('Delete successful:', result);

                // Reload entries from server
                await loadEntries();
                renderEntries();
                updateStats();

                showToast('Entry deleted successfully! üóëÔ∏è');
            } catch (error) {
                console.error('Delete error:', error);
                showToast('Failed to delete: ' + error.message);
            }
        }

        // Render entries
        function renderEntries() {
            const container = document.getElementById('entriesList');
            
            if (entries.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üì≠</div>
                        <div>No entries yet</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = entries.map(entry => {
                // Handle both database format (avatar_type, image_url, cloud_url) and legacy format (avatarType, image)
                const imageUrl = entry.cloud_url || entry.image_url || entry.image;

                const avatarHtml = `<div class="entry-avatar"><img src="${imageUrl}" alt="${entry.name}"></div>`;
                
                return `
                    <div class="entry-card">
                        ${avatarHtml}
                        <div class="entry-info">
                            <div class="entry-name">${entry.name}</div>
                            <div class="entry-type">${entry.type === 'couple' ? 'Couple/Group' : 'Individual'}</div>
                            <div class="entry-votes">
                                ${categories.map(cat => `
                                    <div class="vote-control">
                                        <span class="vote-badge">${cat.emoji} ${entry.votes[cat.id]}</span>
                                        ${entry.votes[cat.id] > 0 ? `<button class="remove-vote-btn" onclick="removeVote(${entry.id}, '${cat.id}')">-</button>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="edit-entry" onclick="editEntry(${entry.id})">‚úé</div>
                        <div class="delete-entry" onclick="deleteEntry(${entry.id})">√ó</div>
                    </div>
                `;
            }).join('');
        }

        // Update stats
        function updateStats() {
            const count = entries.length;
            document.getElementById('entriesCount').textContent = `${count} ${count === 1 ? 'entry' : 'entries'}`;
        }

        // Remove single vote
        async function removeVote(entryId, category) {
            try {
                const response = await fetch('/api/remove-vote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ entryId, category })
                });

                const result = await response.json();

                if (result.success) {
                    // Update local entry data
                    const entry = entries.find(e => e.id === entryId);
                    if (entry) {
                        entry.votes[category] = result.entry.votes[category];
                    }

                    renderEntries();
                    updateStats();
                    showToast('Vote removed! üìâ');
                } else {
                    throw new Error(result.error || 'Failed to remove vote');
                }

            } catch (error) {
                console.error('Remove vote error:', error);
                showToast('Error removing vote: ' + error.message);
            }
        }

        // Reset all votes
        async function resetAllVotes() {
            const confirmed = await showConfirm(
                'This will reset ALL votes to zero. Are you sure?',
                'Reset All Votes'
            );
            if (!confirmed) {
                return;
            }

            try{
                const response = await fetch('/api/reset-votes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Update local entries data
                    entries = result.entries;

                    renderEntries();
                    updateStats();
                    showToast('All votes reset! üîÑ');
                    toggleMenu();
                } else {
                    throw new Error(result.error || 'Failed to reset votes');
                }

            } catch (error) {
                console.error('Reset votes error:', error);
                showToast('Error resetting votes: ' + error.message);
            }
        }

        // Show results with detailed statistics
        async function showResults() {
            try {
                const response = await fetch('/api/vote-stats');
                const stats = await response.json();

                const modal = document.getElementById('resultsModal');
                const content = document.getElementById('resultsContent');

                content.innerHTML = `
                    <div class="stats-summary">
                        <h3>üìä Contest Statistics</h3>
                        <div class="summary-stats">
                            <div class="stat-item">
                                <span class="stat-label">Total Entries:</span>
                                <span class="stat-value">${stats.totalEntries}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Total Votes:</span>
                                <span class="stat-value">${stats.grandTotalVotes}</span>
                            </div>
                        </div>
                    </div>

                    ${stats.categories.map(categoryData => {
                        const categoryInfo = categories.find(c => c.id === categoryData.category);
                        const categoryName = categoryInfo ? categoryInfo.name : categoryData.category;
                        const categoryEmoji = categoryInfo ? categoryInfo.emoji : 'üèÜ';

                        if (categoryData.entries.length === 0) {
                            return `
                                <div class="results-category">
                                    <h3>${categoryEmoji} ${categoryName}</h3>
                                    <div class="category-stats">
                                        <span class="total-votes">Total Votes: ${categoryData.totalVotes}</span>
                                    </div>
                                    <div class="no-winner">No entries in this category</div>
                                </div>
                            `;
                        }

                        const winner = categoryData.entries[0];
                        const allEntries = categoryData.entries.slice(0, 5); // Show top 5

                        return `
                            <div class="results-category">
                                <h3>${categoryEmoji} ${categoryName}</h3>
                                <div class="category-stats">
                                    <span class="total-votes">Total Votes: ${categoryData.totalVotes}</span>
                                </div>

                                ${winner && winner.votes > 0 ? `
                                    <div class="winner">
                                        <div class="avatar">
                                            ${winner.hasValidImage !== false && (winner.cloud_url || winner.image_url || winner.image)
                                                ? `<img src="${winner.cloud_url || winner.image_url || winner.image}" alt="${winner.name}">`
                                                : `<div style="width: 50px; height: 50px; background: rgba(255, 107, 0, 0.3); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: #ff6b00; font-size: 0.8em;">‚ö†Ô∏è</div>`}
                                        </div>
                                        <div class="winner-info">
                                            <div class="winner-name">üèÜ ${winner.name}</div>
                                            <div class="winner-votes">${winner.votes} votes</div>
                                            ${winner.hasValidImage === false ? '<div style="color: #ff4444; font-size: 0.8em;">Image unavailable</div>' : ''}
                                        </div>
                                    </div>

                                    ${allEntries.length > 1 ? `
                                        <div class="other-entries">
                                            <h4>All Results:</h4>
                                            ${allEntries.map((entry, index) => `
                                                <div class="entry-result ${index === 0 ? 'first-place' : ''}">
                                                    <span class="rank">${index + 1}.</span>
                                                    <div class="result-avatar">
                                                        ${entry.hasValidImage !== false && (entry.cloud_url || entry.image_url || entry.image)
                                                            ? `<img src="${entry.cloud_url || entry.image_url || entry.image}" alt="${entry.name}">`
                                                            : `<div style="width: 30px; height: 30px; background: rgba(255, 107, 0, 0.3); border-radius: 6px; display: flex; align-items: center; justify-content: center; color: #ff6b00; font-size: 0.7em;">‚ö†Ô∏è</div>`}
                                                    </div>
                                                    <span class="result-name">${entry.name}${entry.hasValidImage === false ? ' ‚ö†Ô∏è' : ''}</span>
                                                    <span class="result-votes">${entry.votes} votes</span>
                                                </div>
                                            `).join('')}
                                        </div>
                                    ` : ''}
                                ` : `
                                    <div class="no-winner">No votes yet</div>
                                `}
                            </div>
                        `;
                    }).join('')}
                `;

                modal.classList.add('active');
                toggleMenu();

            } catch (error) {
                console.error('Error loading results:', error);
                showToast('Error loading results');
            }
        }

        // Close modal
        function closeModal() {
            document.getElementById('resultsModal').classList.remove('active');
        }

        // Clear all data
        async function clearAllData() {
            const confirmed = await showConfirm(
                'This will permanently delete ALL contest entries and votes from the database. This cannot be undone! Are you sure?',
                'Clear All Data'
            );
            if (!confirmed) {
                return;
            }

            try {
                console.log('Deleting all entries from database...');
                const response = await fetch('/api/entries', {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Delete all failed');
                }

                const result = await response.json();
                console.log('Delete all successful:', result);

                // Reload entries from server (should be empty now)
                await loadEntries();
                renderEntries();
                updateStats();

                showToast(`All data cleared! (${result.deletedCount} entries deleted)`);
                toggleMenu();
            } catch (error) {
                console.error('Clear all data error:', error);
                showToast('Failed to clear data: ' + error.message);
            }
        }

        // Export data
        function exportData() {
            const dataStr = JSON.stringify(entries, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `halloween-contest-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showToast('Data exported');
            toggleMenu();
        }

        // Edit entry functions

        function editEntry(id) {
            const entry = entries.find(e => e.id === id);
            if (!entry) return;

            editingEntry = entry;

            // Populate form fields
            document.getElementById('editEntryName').value = entry.name;
            document.getElementById('editEntryType').value = entry.type;

            // Handle both database format and legacy format
            const imageUrl = entry.cloud_url || entry.image_url || entry.image;

            // Show image preview
            if (imageUrl) {
                document.getElementById('editPreviewImg').src = imageUrl;
                document.getElementById('editImagePreview').style.display = 'block';
            }

            // Show modal
            document.getElementById('editModal').classList.add('active');
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
            editingEntry = null;

            // Reset form
            document.getElementById('editEntryName').value = '';
            document.getElementById('editEntryType').value = 'individual';
            document.getElementById('editImagePreview').style.display = 'none';
        }

        async function saveEditEntry() {
            const name = document.getElementById('editEntryName').value.trim();
            const type = document.getElementById('editEntryType').value;

            if (!name) {
                showToast('Please enter a name!');
                return;
            }

            if (!editingEntry) return;

            try {
                console.log('Updating entry:', editingEntry.id);

                // Prepare update data (only name and type, photo cannot be changed)
                const updates = {
                    name: name,
                    type: type
                };

                console.log('Sending updates:', updates);

                const response = await fetch(`/api/entries/${editingEntry.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updates)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Update failed');
                }

                const result = await response.json();
                console.log('Update successful:', result);

                // Reload entries from server
                await loadEntries();
                renderEntries();
                closeEditModal();
                showToast('Entry updated successfully! ‚ú®');
            } catch (error) {
                console.error('Update error:', error);
                showToast('Failed to update: ' + error.message);
            }
        }

        // Toggle menu
        function toggleMenu() {
            const menu = document.getElementById('sideMenu');
            const overlay = document.getElementById('menuOverlay');
            menu.classList.toggle('active');
            overlay.classList.toggle('active');
        }

        // Show toast
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // Custom confirmation modal (replaces browser confirm())
        function showConfirm(message, title = 'Confirm Action') {
            return new Promise((resolve) => {
                const overlay = document.getElementById('confirmModalOverlay');
                const titleEl = document.getElementById('confirmModalTitle');
                const messageEl = document.getElementById('confirmModalMessage');
                const cancelBtn = document.getElementById('confirmModalCancel');
                const confirmBtn = document.getElementById('confirmModalConfirm');

                titleEl.textContent = title;
                messageEl.textContent = message;
                overlay.classList.add('active');

                const cleanup = () => {
                    overlay.classList.remove('active');
                    cancelBtn.removeEventListener('click', handleCancel);
                    confirmBtn.removeEventListener('click', handleConfirm);
                };

                const handleCancel = () => {
                    cleanup();
                    resolve(false);
                };

                const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                };

                cancelBtn.addEventListener('click', handleCancel);
                confirmBtn.addEventListener('click', handleConfirm);
            });
        }

        // Secret key sequence handler
        function handleSecretKey(event) {
            // Only track letter keys
            if (event.key.length === 1 && /[a-zA-Z]/.test(event.key)) {
                keySequence += event.key.toLowerCase();
                
                // Keep only last 5 characters
                if (keySequence.length > 5) {
                    keySequence = keySequence.slice(-5);
                }
                
                // Check if secret sequence matches
                if (keySequence === secretTrigger) {
                    keySequence = ''; // Reset
                    window.location.href = 'index.html';
                }
            }
        }

        // Timing Management Functions
        let timingSettings = {
            enabled: false,
            votingStart: '2025-10-25T19:00',
            votingEnd: '2025-10-25T21:00',
            manualOverride: null // 'preshow', 'voting', 'closed', or null for auto
        };

        // Toggle timing card expansion
        function toggleTimingCard() {
            const content = document.getElementById('timingCardContent');
            const toggle = document.getElementById('timingCardToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        async function toggleTimingSettings() {
            const mode = document.getElementById('timingMode').value;
            const settings = document.getElementById('timingSettings');
            const overrides = document.getElementById('manualOverrides');
            const content = document.getElementById('timingCardContent');
            const toggle = document.getElementById('timingCardToggle');

            console.log('[ADMIN] Toggling timing mode to:', mode);

            if (mode === 'enabled') {
                settings.style.display = 'block';
                overrides.style.display = 'block';
                timingSettings.enabled = true;

                // Expand the card when enabling timing
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                settings.style.display = 'none';
                overrides.style.display = 'none';
                timingSettings.enabled = false;

                // Optionally collapse when disabling (user can still manually expand)
                // Uncomment the next two lines if you want it to auto-collapse on disable:
                // content.style.display = 'none';
                // toggle.textContent = '‚ñ∂';
            }

            // Save enabled state to database
            try {
                console.log('[ADMIN] Saving enabled state to database:', timingSettings.enabled);
                const response = await fetch('/api/timing-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(timingSettings)
                });

                const result = await response.json();

                if (response.ok) {
                    console.log('[ADMIN] ‚úÖ Timing enabled state saved to database');
                    showToast(`Timing ${timingSettings.enabled ? 'enabled' : 'disabled'} and saved to database`);
                } else {
                    console.error('[ADMIN] ‚ùå Failed to save timing enabled state:', result);
                    showToast('Error: Failed to save timing enabled state');
                }
            } catch (error) {
                console.error('[ADMIN] ‚ùå Error saving timing enabled state:', error);
                showToast('Error saving timing state: ' + error.message);
            }

            updateTimingStatus();
        }

        async function saveTimingSettings() {
            console.log('[ADMIN] Saving timing settings...');
            console.log('[ADMIN] Current settings:', JSON.stringify(timingSettings, null, 2));

            // Get values from form
            timingSettings.votingStart = document.getElementById('votingStart').value;
            timingSettings.votingEnd = document.getElementById('votingEnd').value;

            console.log('[ADMIN] Updated settings:', JSON.stringify(timingSettings, null, 2));

            // Validate times (voting start must be before voting end)
            const votingStart = new Date(timingSettings.votingStart);
            const votingEnd = new Date(timingSettings.votingEnd);

            if (votingStart >= votingEnd) {
                console.error('[ADMIN] Validation error: Start time must be before end time');
                showToast('Error: Voting start time must be before voting end time!');
                return;
            }

            // Save to server (database)
            try {
                console.log('[ADMIN] Sending to /api/timing-settings...');
                const response = await fetch('/api/timing-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(timingSettings)
                });

                const result = await response.json();
                console.log('[ADMIN] Server response:', result);

                if (response.ok) {
                    console.log('[ADMIN] ‚úÖ Timing settings saved successfully to database');
                    showToast('‚úÖ Timing settings saved to database!');
                    updateTimingStatus();
                } else {
                    console.error('[ADMIN] ‚ùå Server returned error:', result);
                    showToast('Error: ' + (result.error || 'Failed to save timing settings'));
                }
            } catch (error) {
                console.error('[ADMIN] ‚ùå Error saving timing settings:', error);
                showToast('Error saving timing settings: ' + error.message);
            }
        }

        // Load timing settings from API (database)
        async function loadTimingFromAPI() {
            console.log('[ADMIN] Loading timing settings from database...');
            try {
                const response = await fetch('/api/timing-status');
                if (response.ok) {
                    const data = await response.json();
                    timingSettings = data.settings;

                    console.log('[ADMIN] ‚úÖ Loaded from database:', JSON.stringify(timingSettings, null, 2));
                    console.log('[ADMIN] Current phase:', data.currentPhase);

                    // Update form fields
                    document.getElementById('timingMode').value = timingSettings.enabled ? 'enabled' : 'disabled';
                    document.getElementById('votingStart').value = timingSettings.votingStart;
                    document.getElementById('votingEnd').value = timingSettings.votingEnd;

                    toggleTimingSettings();
                } else {
                    console.error('[ADMIN] ‚ùå Failed to load timing settings from API, status:', response.status);
                    showToast('Warning: Could not load timing settings from database');
                }
            } catch (error) {
                console.error('[ADMIN] ‚ùå Error loading timing settings:', error);
                showToast('Error loading timing settings: ' + error.message);
            }

            // Set initial collapsed/expanded state based on timing enabled status
            const content = document.getElementById('timingCardContent');
            const toggle = document.getElementById('timingCardToggle');

            if (!timingSettings.enabled) {
                // Collapse if timing is disabled
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            } else {
                // Expand if timing is enabled
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            }
        }

        // Get current time in Eastern timezone
        function getNowInEastern() {
            const now = new Date();
            // Convert to Eastern Time using Intl API
            const formatter = new Intl.DateTimeFormat('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            const parts = formatter.formatToParts(now);
            const dateObj = {};
            parts.forEach(({ type, value }) => {
                dateObj[type] = value;
            });

            // Create ISO string in Eastern Time then parse as UTC for comparison
            const easternISO = `${dateObj.year}-${dateObj.month}-${dateObj.day}T${dateObj.hour}:${dateObj.minute}:${dateObj.second}`;
            return new Date(easternISO + 'Z'); // Treat as UTC for comparison
        }

        // Format time for display in Eastern Time
        function formatEasternTime(date) {
            return date.toLocaleString('en-US', {
                timeZone: 'America/New_York',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            }) + ' ET';
        }

        function getCurrentPhase() {
            if (!timingSettings.enabled) {
                return { phase: 'disabled', message: 'Timing controls disabled - voting always available' };
            }

            if (timingSettings.manualOverride) {
                const phases = {
                    'preshow': { phase: 'preshow', message: 'Pre-show period (Manual Override)', icon: 'üé≠' },
                    'voting': { phase: 'voting', message: 'Voting active (Manual Override)', icon: 'üó≥Ô∏è' },
                    'closed': { phase: 'closed', message: 'Voting closed (Manual Override)', icon: 'üîí' }
                };
                return phases[timingSettings.manualOverride] || phases['closed'];
            }

            // Get current time in Eastern and convert settings times to Eastern for comparison
            const now = getNowInEastern();
            const votingStart = new Date(timingSettings.votingStart + ':00Z');
            const votingEnd = new Date(timingSettings.votingEnd + ':00Z');

            // Before voting period = pre-show
            if (now < votingStart) {
                return {
                    phase: 'preshow',
                    message: 'Pre-show period - Uploads allowed, voting disabled',
                    icon: 'üé≠',
                    next: `Voting starts ${formatEasternTime(votingStart)}`
                };
            }
            // During voting period = voting active
            else if (now >= votingStart && now < votingEnd) {
                return {
                    phase: 'voting',
                    message: 'Voting is ACTIVE!',
                    icon: 'üó≥Ô∏è',
                    next: `Voting ends ${formatEasternTime(votingEnd)}`
                };
            }
            // After voting period = closed
            else {
                return {
                    phase: 'closed',
                    message: 'Contest closed - No uploads or voting allowed',
                    icon: 'üîí',
                    next: ''
                };
            }
        }

        function updateTimingStatus() {
            const status = getCurrentPhase();
            const phaseIcon = document.getElementById('phaseIcon');
            const currentPhase = document.getElementById('currentPhase');
            const nextPhase = document.getElementById('nextPhase');

            if (status.icon) phaseIcon.textContent = status.icon;
            currentPhase.textContent = status.message;
            nextPhase.textContent = status.next || '';

            // Update status background color based on phase
            const statusDiv = document.querySelector('.timing-status > div');
            statusDiv.style.background = getPhaseColor(status.phase);
            statusDiv.style.borderColor = getPhaseBorderColor(status.phase);
        }

        function getPhaseColor(phase) {
            const colors = {
                'disabled': 'rgba(255, 107, 0, 0.1)',
                'beforeshow': 'rgba(100, 100, 100, 0.1)',
                'preshow': 'rgba(255, 255, 0, 0.1)',
                'voting': 'rgba(0, 255, 0, 0.1)',
                'closed': 'rgba(255, 0, 0, 0.1)',
                'results': 'rgba(255, 215, 0, 0.1)'
            };
            return colors[phase] || colors['disabled'];
        }

        function getPhaseBorderColor(phase) {
            const colors = {
                'disabled': 'rgba(255, 107, 0, 0.3)',
                'beforeshow': 'rgba(100, 100, 100, 0.3)',
                'preshow': 'rgba(255, 255, 0, 0.3)',
                'voting': 'rgba(0, 255, 0, 0.3)',
                'closed': 'rgba(255, 0, 0, 0.3)',
                'results': 'rgba(255, 215, 0, 0.3)'
            };
            return colors[phase] || colors['disabled'];
        }

        async function setPhase(phase) {
            if (phase === 'auto') {
                timingSettings.manualOverride = null;
                showToast('Returned to automatic timing');
            } else {
                timingSettings.manualOverride = phase;
                const phaseNames = {
                    'preshow': 'Pre-show',
                    'voting': 'Voting',
                    'closed': 'Voting Closed'
                };
                showToast(`Manually set to ${phaseNames[phase]} phase`);
            }

            // Save to server
            try {
                await fetch('/api/timing-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(timingSettings)
                });
            } catch (error) {
                console.error('Error saving manual override:', error);
            }

            updateTimingStatus();
        }

        // Initialize timing on load
        async function initTiming() {
            await loadTimingFromAPI();
            updateTimingStatus();

            // Update status every 30 seconds
            setInterval(updateTimingStatus, 30000);
        }

        // Initialize on load
        window.addEventListener('load', () => {
            init();
            initTiming();
        });
        
        // Add secret key listener
        document.addEventListener('keydown', handleSecretKey);
    </script>
</body>
</html>